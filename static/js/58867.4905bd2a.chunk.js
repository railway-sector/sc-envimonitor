"use strict";(self.webpackChunksc_envimonitor=self.webpackChunksc_envimonitor||[]).push([[58867],{27040:(t,e,n)=>{n.r(e),n.d(e,{createMesh:()=>d});var o=n(50076),r=n(47594),i=n(45308),a=n(42294),s=n(14894),l=n(56623),c=n(45136),u=n(95799);function d(t){var e,n;const a=new u.O,d=null!==(e=t.spatialReference)&&void 0!==e?e:t.layerView.view.spatialReference;return a.externalSources.add({extent:null!==(n=t.extent)&&void 0!==n?n:p(t,d),source:{type:"loadable",load:e=>async function(t,e){let{layerView:n,nodeIndex:r,featureIndex:a}=e;const s=n.getNodeComponentHandle(r);if(null===s||void 0===s||!s.intersectionGeometry)throw new o.A("i3s-layer-view-geometry-missing","Cannot load mesh because scene layer view data is no longer available.");const u={indices:null,data:null,stride:0,startIndex:0,endIndex:0};s.intersectionGeometry.getComponentPositions(a,u);const{indices:d,data:p,stride:x,startIndex:h,endIndex:v}=u,y=new Float64Array(3*(v-h));let f=0;for(let o=h;o<v;o+=3){const t=x*d[o],e=x*d[o+1],n=x*d[o+2];y[f++]=p[t],y[f++]=p[t+1],y[f++]=p[t+2],y[f++]=p[e],y[f++]=p[e+1],y[f++]=p[e+2],y[f++]=p[n],y[f++]=p[n+1],y[f++]=p[n+2]}const w=s.transform;(0,c.b)(y,y,w.rotationScale),(0,c.a)(y,y,w.position),(0,i.projectBuffer)(y,n.view.renderSpatialReference,0,y,t.spatialReference,0),t.vertexAttributes=new l.H({position:y})}(e,t)}}),new r.default({metadata:a,vertexSpace:new s.A,spatialReference:d})}function p(t,e){let{layerView:n,nodeIndex:o,featureIndex:r}=t;const s=n.getAABB(o,r);if(!s)return null;const l=n.view.spatialReference;return l.equals(e)||(0,i.projectBuffer)(s,l,0,s,e,0),(0,a.w1)(s,e)}},32186:(t,e,n)=>{n.d(e,{A:()=>v});var o,r,i=n(35143),a=n(42553),s=n(46053),l=(n(81806),n(76460),n(47249),n(85842)),c=n(34761),u=n(13191),d=n(60008),p=n(4336),x=n(9392),h=n(52896);let v=(o=class extends a.A{constructor(t){super(t),this.translation=(0,x.vt)(),this.rotationAxis=(0,x.ci)(h.up),this.rotationAngle=0,this.scale=(0,x.fA)(1,1,1)}get rotation(){return(0,h.i4)(this.rotationAxis,this.rotationAngle)}set rotation(t){this.rotationAxis=(0,x.o8)((0,h.yo)(t)),this.rotationAngle=(0,h.g7)(t)}get localMatrix(){const t=(0,u.vt)();return(0,d.x8)(y,(0,h.yo)(this.rotation),(0,h.$I)(this.rotation)),(0,c.o1)(t,y,this.translation,this.scale),t}get localMatrixInverse(){return(0,c.B8)((0,u.vt)(),this.localMatrix)}equals(t){return this===t||null!=t&&(0,c.t2)(this.localMatrix,t.localMatrix)}clone(){const t={translation:(0,x.o8)(this.translation),rotationAxis:(0,x.o8)(this.rotationAxis),rotationAngle:this.rotationAngle,scale:(0,x.o8)(this.scale)};return new r(t)}},r=o,o);(0,i._)([(0,s.MZ)({type:[Number],nonNullable:!0,json:{write:!0}})],v.prototype,"translation",void 0),(0,i._)([(0,s.MZ)({type:[Number],nonNullable:!0,json:{write:!0}})],v.prototype,"rotationAxis",void 0),(0,i._)([(0,s.MZ)({type:Number,nonNullable:!0,json:{write:!0}})],v.prototype,"rotationAngle",void 0),(0,i._)([(0,s.MZ)({type:[Number],nonNullable:!0,json:{write:!0}})],v.prototype,"scale",void 0),(0,i._)([(0,s.MZ)()],v.prototype,"rotation",null),(0,i._)([(0,s.MZ)()],v.prototype,"localMatrix",null),(0,i._)([(0,s.MZ)()],v.prototype,"localMatrixInverse",null),v=r=(0,i._)([(0,l.$)("esri.geometry.support.MeshTransform")],v);const y=(0,p.vt)()}}]);
//# sourceMappingURL=58867.4905bd2a.chunk.js.map